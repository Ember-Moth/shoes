//! H2MUX Client Session
//!
//! Manages a single HTTP/2 connection for multiplexing multiple streams.
//! Includes idle timeout, PING keepalive, and stream open timeout.

use std::io;
use std::sync::atomic::{AtomicBool, AtomicU32, Ordering};
use std::sync::Arc;

use bytes::Bytes;
use h2::{Ping, PingPong};
use http::{Method, Request, Version};
use log::debug;
use tokio::io::{AsyncRead, AsyncWrite};
use tokio::time::interval;

use crate::address::NetLocation;
use crate::async_stream::AsyncStream;

use super::activity_tracker::{
    ActivityTracker, IDLE_TIMEOUT, PING_INTERVAL, PING_TIMEOUT, STREAM_OPEN_TIMEOUT,
};
use super::h2mux_client_stream::H2MuxClientStream;
use super::h2mux_padding::H2MuxPaddingStream;
use super::h2mux_protocol::SessionRequest;
use super::H2MuxOptions;

/// HTTP/2 window and frame size configuration.
/// Using defaults that match golang's http2 package for compatibility.
const WINDOW_SIZE: u32 = 1024 * 1024; // 1 MB
const MAX_FRAME_SIZE: u32 = 16384; // 16 KB (HTTP/2 default)

/// Client session managing multiplexed streams over a single H2 connection.
///
/// Includes:
/// - Idle timeout (30s) - closes session when no activity
/// - PING keepalive (30s) - detects dead connections
/// - Stream open timeout (5s) - prevents hanging on unresponsive servers
pub struct H2MuxClientSession {
    send_request: h2::client::SendRequest<Bytes>,
    /// Handle to abort the connection driver on drop
    driver_handle: Arc<DriverHandle>,
    padding_enabled: bool,
    /// Approximate count of open streams. Only incremented, never decremented.
    /// TODO: For proper session pooling, wrap streams in a guard that decrements on drop.
    active_streams: AtomicU32,
    /// Tracks last activity for idle timeout
    activity: ActivityTracker,
    /// Closed flag - set by idle watchdog or ping failure
    is_closed: Arc<AtomicBool>,
}

impl std::fmt::Debug for H2MuxClientSession {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("H2MuxClientSession")
            .field("padding_enabled", &self.padding_enabled)
            .field("active_streams", &self.active_streams.load(Ordering::Relaxed))
            .field("is_closed", &self.is_closed.load(Ordering::Relaxed))
            .finish()
    }
}

/// RAII wrapper to abort the driver when all session clones are dropped
struct DriverHandle(tokio::task::AbortHandle);

impl Drop for DriverHandle {
    fn drop(&mut self) {
        debug!("H2MuxClientSession: aborting connection driver");
        self.0.abort();
    }
}

impl Clone for H2MuxClientSession {
    fn clone(&self) -> Self {
        Self {
            send_request: self.send_request.clone(),
            driver_handle: Arc::clone(&self.driver_handle),
            padding_enabled: self.padding_enabled,
            active_streams: AtomicU32::new(self.active_streams.load(Ordering::Relaxed)),
            activity: self.activity.clone(),
            is_closed: Arc::clone(&self.is_closed),
        }
    }
}

impl H2MuxClientSession {
    /// Create a new client session from a raw connection.
    ///
    /// This performs:
    /// 1. Send session request header on RAW stream (unpadded)
    /// 2. Apply padding layer if enabled
    /// 3. Perform HTTP/2 handshake over (potentially padded) stream
    /// 4. Spawn connection driver, idle watchdog, and PING keepalive tasks
    pub async fn new<IO>(mut conn: IO, options: &H2MuxOptions) -> io::Result<Self>
    where
        IO: AsyncRead + AsyncWrite + Unpin + Send + 'static,
    {
        // Send session request header on RAW stream (before padding)
        let session_req = SessionRequest::new(options.protocol, options.padding);
        session_req.write(&mut conn).await?;

        // Apply padding and perform handshake
        if options.padding {
            let padded = H2MuxPaddingStream::new(conn);
            Self::handshake_and_spawn(padded, options.padding).await
        } else {
            Self::handshake_and_spawn(conn, options.padding).await
        }
    }

    /// Perform HTTP/2 handshake and spawn driver + timeout tasks.
    async fn handshake_and_spawn<IO>(conn: IO, padding_enabled: bool) -> io::Result<Self>
    where
        IO: AsyncRead + AsyncWrite + Unpin + Send + 'static,
    {
        let (send_request, mut connection) = h2::client::Builder::new()
            .initial_window_size(WINDOW_SIZE)
            .initial_connection_window_size(WINDOW_SIZE)
            .max_frame_size(MAX_FRAME_SIZE)
            .handshake(conn)
            .await
            .map_err(|e| {
                io::Error::new(
                    io::ErrorKind::Other,
                    format!("H2 client handshake failed: {}", e),
                )
            })?;

        // Take ping_pong handle before spawning - can only be called once
        let ping_pong = connection.ping_pong();

        let activity = ActivityTracker::new();
        let is_closed = Arc::new(AtomicBool::new(false));

        // Spawn connection driver
        let abort_handle = tokio::spawn(async move {
            if let Err(e) = connection.await {
                debug!("H2MUX client connection ended: {}", e);
            }
        })
        .abort_handle();

        // Spawn idle timeout watchdog
        Self::spawn_idle_watchdog(activity.clone(), Arc::clone(&is_closed));

        // Spawn PING keepalive task
        if let Some(pp) = ping_pong {
            Self::spawn_ping_task(pp, activity.clone(), Arc::clone(&is_closed));
        }

        debug!("H2MuxClientSession: ready for multiplexing");

        Ok(Self {
            send_request,
            driver_handle: Arc::new(DriverHandle(abort_handle)),
            padding_enabled,
            active_streams: AtomicU32::new(0),
            activity,
            is_closed,
        })
    }

    /// Spawn idle timeout watchdog task.
    /// Checks periodically and marks session closed when idle too long.
    fn spawn_idle_watchdog(activity: ActivityTracker, is_closed: Arc<AtomicBool>) {
        tokio::spawn(async move {
            // Check 6 times per timeout period for responsiveness
            let check_interval = IDLE_TIMEOUT / 6;
            let mut timer = interval(check_interval);
            timer.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Delay);
            // Skip the first tick which returns immediately
            timer.tick().await;

            loop {
                timer.tick().await;

                if is_closed.load(Ordering::Relaxed) {
                    break;
                }

                if activity.is_idle(IDLE_TIMEOUT) {
                    debug!("H2MUX client: idle timeout reached");
                    is_closed.store(true, Ordering::Relaxed);
                    break;
                }
            }
        });
    }

    /// Spawn PING keepalive task.
    /// Sends periodic PINGs when idle to detect dead connections.
    /// PING does NOT reset idle timeout (per Go http2 spec).
    fn spawn_ping_task(mut ping_pong: PingPong, activity: ActivityTracker, is_closed: Arc<AtomicBool>) {
        tokio::spawn(async move {
            let mut timer = interval(PING_INTERVAL);
            timer.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Delay);
            // Skip the first tick which returns immediately
            timer.tick().await;

            loop {
                timer.tick().await;

                if is_closed.load(Ordering::Relaxed) {
                    break;
                }

                // Only ping if connection has been idle
                if activity.idle_duration() < PING_INTERVAL {
                    continue;
                }

                // Send PING and wait for PONG
                match tokio::time::timeout(PING_TIMEOUT, ping_pong.ping(Ping::opaque())).await {
                    Ok(Ok(_pong)) => {
                        // PING successful - connection is alive
                        // Note: Do NOT record_activity() - PING doesn't reset idle timeout
                        debug!("H2MUX client: PING/PONG successful");
                    }
                    Ok(Err(e)) => {
                        debug!("H2MUX client: PING failed: {}", e);
                        is_closed.store(true, Ordering::Relaxed);
                        break;
                    }
                    Err(_) => {
                        debug!("H2MUX client: PING timeout");
                        is_closed.store(true, Ordering::Relaxed);
                        break;
                    }
                }
            }
        });
    }

    /// Check if the session is still usable.
    pub fn is_ready(&self) -> bool {
        !self.is_closed.load(Ordering::Relaxed)
    }

    /// Get the number of active streams.
    #[allow(dead_code)]
    pub fn active_streams(&self) -> u32 {
        self.active_streams.load(Ordering::Relaxed)
    }

    /// Open a new TCP stream to the specified destination.
    pub async fn open_tcp(&mut self, destination: &NetLocation) -> io::Result<Box<dyn AsyncStream>> {
        self.open_stream_with_timeout(destination, true).await
    }

    /// Open a new UDP stream to the specified destination.
    pub async fn open_udp(
        &mut self,
        destination: &NetLocation,
        _packet_addr: bool,
    ) -> io::Result<Box<dyn AsyncStream>> {
        self.open_stream_with_timeout(destination, false).await
    }

    /// Open stream with timeout wrapper.
    async fn open_stream_with_timeout(
        &mut self,
        destination: &NetLocation,
        is_tcp: bool,
    ) -> io::Result<Box<dyn AsyncStream>> {
        if self.is_closed.load(Ordering::Relaxed) {
            return Err(io::Error::new(
                io::ErrorKind::NotConnected,
                "H2MUX session is closed",
            ));
        }

        tokio::time::timeout(STREAM_OPEN_TIMEOUT, self.open_stream(destination, is_tcp))
            .await
            .map_err(|_| {
                io::Error::new(
                    io::ErrorKind::TimedOut,
                    format!("H2MUX stream open timeout to {}", destination),
                )
            })?
    }

    /// Open a new stream with the given destination.
    ///
    /// Uses lazy stream pattern matching sing-mux's behavior:
    /// - Returns immediately after sending CONNECT request
    /// - Response is resolved asynchronously on first read
    /// - StreamRequest is prepended to first write
    /// - Status response is read on first read
    async fn open_stream(
        &mut self,
        destination: &NetLocation,
        is_tcp: bool,
    ) -> io::Result<Box<dyn AsyncStream>> {
        // Record activity - opening a stream counts
        self.activity.record_activity();

        // Create CONNECT request - h2 crate handles proper pseudo-header encoding
        let http_request = Request::builder()
            .method(Method::CONNECT)
            .uri("https://localhost")
            .version(Version::HTTP_2)
            .body(())
            .map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;

        // Send CONNECT request
        let (response_future, send_stream) = self
            .send_request
            .send_request(http_request, false)
            .map_err(|e| {
                io::Error::new(
                    io::ErrorKind::Other,
                    format!("Failed to send CONNECT: {}", e),
                )
            })?;

        // Create unified client stream with lazy response resolution
        let client_stream =
            H2MuxClientStream::new(send_stream, response_future, destination.clone(), is_tcp);

        self.active_streams.fetch_add(1, Ordering::Relaxed);

        debug!("H2MuxClientSession: opened stream to {}", destination);

        Ok(Box::new(client_stream))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_session_clone() {
        fn assert_clone<T: Clone>() {}
        assert_clone::<H2MuxClientSession>();
    }
}
